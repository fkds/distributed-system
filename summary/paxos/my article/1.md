```
(1) Priest p chooses a new ballot number b and sends a NextBallot(b) messag e to
some set of priests.

(2) A priest q responds to the receipt of a NextBallot(b) message by sending a
LastVote(b, v) message to p, where v is the vote with the largest ballot number
less than b that q has cast, or his null vote null q if q did not vote in any ballot
numbered less than b.

(3) After receiving a LastVote(b, v) message from every priest in some majority
set Q, priest p initiates a new ballot with number b, quorum Q, and decree d,
where d is chosen to satisfy B3. He then records the ballot in the back of his
ledger and sends a BeginBallot(b, d) message to every priest in Q.

(4) Upon receipt of the BeginBallot(b, d) message, priest q decides whether or not
to cast his vote in ballot number b. (He may not cast the vote if doingso
would violate a promise implied by a LastVote(b, v) message he has sent for
some other ballot.) If q decides to vote for ballot number b, then he sends a
Voted(b, q) message to p and records the vote in the back of his ledger.

(5) If p has received a Voted(b, q) message from every priest q in Q (the quorum
for ballot number b), then he writes d (the decree of that ballot) in his ledger
and sends a Success(d) message to every priest.

(6) Upon receiving a Success(d) message, a priest enters decree d in his ledger.


type Priest struct {
    Address
    Clients

    Timer
    ServerChannel

    FirstDecree
    FinalDecree
    Vote

    Ballot
    BallotQuorum
    BallotAcks
    BallotVote
}

type Message struct {
    Ballot
    Type
    From
    To
    Content
}

function generateQuorum(p: Priest) {

}

function run(p: Priest) {
    for {
        select {
            m <- r.Timer
            m <- r.ServerChannel
                p.handle(m)
        }
    }
}

function handle(p: Priest, m: Message) {
    switch (m.Type) {
        case Timeout:
            p.handleTimeout(m)
        case NextBallot:
            p.handleNextBallot(m)
        case LastVote:
            p.handleLastVote(m)
        case BeginBallot:
            p.handleBeginBallot(m)
        case Voted:
            p.handleVoted(m)
        case Success:
            p.handleSuccess(m)
    }
}

function handleTimeout(p: Priest, m: Message) {
    if (p.FinalDecree != null) {
        return
    }
    
    p.Ballot.Save(Ballot{
        Id: p.Address,
        No: p.Ballot.No + 1
    })
    p.BallotQuorum = p.generateQuorum()
    p.BallotAcks = 0
    p.BallotVote = null
 
    for address in p.BallotQuorum {
        m = Message {
            Ballot: p.Ballot,
            Type:   NextBallot,
            From:   p.Address,
            To:     address
        }
        p.Clients[address].Send(m)
    }
}

function handleNextBallot(p: Priest, m: Message) {
    if (m.Ballot < p.Ballot) {
        m = Message {
            Ballot: p.Ballot,
            Type:   LastVote,
            From:   m.To,
            To:     m.From,
        }
        goto end
    }

    if (m.Ballot >= p.Ballot) {
        p.Ballot.Save(m.Ballot)
        m = Messge {
            Ballot:  p.Ballot,
            Type:    LastVote,
            From:    m.To,
            To:      m.From,
            Content: {"vote": p.Vote}
        }
        goto end
    }

end:
    p.Clients[m.To].Send(m)
}

function handleLastVote(p: Priest, m: Message) {
    if (m.Ballot < p.Ballot) {
        return
    }

    if (m.Ballot == p.Ballot) {
        p.BallotAcks++
        if (m.content["vote"] != null && (p.BallotVote == null || p.BallotVote.Ballot < m.content["vote"].Ballot)) {
            p.BallotVote = m.content["vote"]
        }
        if (p.BallotAcks == len(p.BallotQuorum)) {
            p.BallotAcks = 0
            if (p.BallotVote != null) {
                decree = p.BallotVote.Decree
            } else if (p.Vote != null) {
                decree = p.Vote.Decree
            } else if (p.FirstDecree != null) {
                decree = p.FristDecree
            } else {
                return
            }
            p.Vote.Save(Vote{
                Ballot: p.Ballot,
                Decree: decree
            })
            for address in p.BallotQuorum {
                m = Message {
                    Ballot:  p.Ballot,
                    Type:    BeginBallot,
                    From:    p.Address,
                    To:      address,
                    Content: {"decree": decree}
                }
                p.Clients[address].Send(m)
            }
        }
        return
    }

    if (m.Ballot > p.Ballot) {
        p.Ballot.Save(m.Ballot)
        return
    }
}

function handleBeginBallot(p: Priest, m: Message) {
    if (m.Ballot < p.Ballot) {
        m = Message {
            Ballot:  p.Ballot,
            Type:    Voted,
            From:    m.To,
            To:      m.From
        }
        goto end
    }

    if (m.Ballot >= p.Ballot) {
        p.Ballot.Save(m.Ballot)
        p.Vote.Save(Vote{
            Ballot: p.Ballot,
            Decree: m.Content["decree"]
        })
        m = Message {
            Ballot:  p.Ballot,
            Type:    Voted,
            From:    m.To,
            To:      m.From,
        }
        goto end
    }

end:
    p.Clients[m.To].Send(m)
}

function handleVoted(p: Priest, m: Message) {
    if (m.Ballot < p.Ballot) {
        return 
    }

    if (m.Ballot == p.Ballot) {
        p.BallotAcks++
        if (p.BallotAcks == len(p.BallotQuorum)) {
            p.FinalDecree.Save(p.Vote.Decree)
            for address in p.Clients {
                m = Message {
                    Ballot:  p.Ballot,
                    Type:    Success,
                    From:    p.Address,
                    To:      address,
                    Content: {"decree": p.FinalDecree}
                }
                p.Clients[address].Send(m)
            }
        }
        return
    }

    if (m.Ballot > p.Ballot) {
        p.Ballot.Save(m.Ballot)
        return
    }
}

function handleSuccess(p: Priest, m: Message) {
    p.FinalDecree.Save(m.Content["decree"])
}
```
