## log replication: async algorithm

|           | ClientRequest       | VoteRequest       | VoteResponse       | AppendRequest       | AppendResponse       | Timeout                |
| --------- | ------------------- | ----------------- | -------------------| ------------------- | -------------------- | ---------------------- |
| Leader    | handleClientRequest | handleVoteRequest | handleVoteResponse | handleAppendRequest | handleAppendResponse | handleLeaderTimeout    |
| Follower  | undefined           | handleVoteRequest | handleVoteResponse | handleAppendRequest | handleAppendResponse | handleFollowerTimeout  |
| Candidate | undefined           | handleVoteRequest | handleVoteResponse | handleAppendRequest | handleAppendResponse | handleCandidateTimeout |

```
class Message {
    term         // term of node which send
    type         // ClientRequest, VoteRequest, VoteResponse, AppendRequest, AppendResponse, Timeout
    from         // id of node which send
    to           // id of node which recv
    index        // index of record in progress of node which send
    cindex       // client index
    prevLogTerm  // term of previous log
    prevLogIndex // index of previous log
    lastLogTerm  // term of last log
    lastLogIndex // index of last log
    log          // log
    channel      // used to wait response
    ok           // response
    consistency  // consistency
}
```

```
class Task {
    message
    success
    failure
}
```

```
class Raft {
    id              // identity of current node

    state           // Leader, Follower, Candidate  (volatile)
    term            // current term at current node (persistent)
    votedFor        // which node voted for         (persistent)
    
    log             // log                          (persistent)
    
    timer           // current timer
    leaderTimer     // send heart beat if time out
    followerTimer   // vote for self if time out
    candidateTimer  // revote for self if time out
    
    serverChannel   // receive message from server
    clients         // send message to clients
    clientIndex     // clientIndex
    
    progress        // record the client and vote handle progress
    index           // last record index
}
```

```
function InitRaft(r: Raft) {
    r.becomeFollowerWithRead()
    go r.raftLoop()
}
```

```
function becomeLeader(r: Raft) {
    r.state = Leader
    r.timer = r.leaderTimer
    r.timer.Reset()
    for c in r.clients
        r.clientIndex[c] = len(r.log) + 1
}
```

```
function becomeFollower(r: Raft) {
    r.state = Follower
    r.timer = r.followerTimer
    r.timer.Reset()
}
```

```
function becomeFollowerWithRead(r: Raft) {
    r.state = Follower
    r.term, r.votedFor = readStorage()
    r.timer = r.follwerTimer
    r.timer.Reset()
}
```

```
function becomeFollowerWithWrite(r: Raft, term, votedFor) {
    r.state = Follower
    r.term = term
    r.votedFor = votedFor
    writeStorage(term, votedFor)
    r.timer = r.followerTimer
    r.timer.Reset()
}
```

```
function becomeCandidate(r: Raft) {
    r.state = Candidate
    r.term++
    r.votedFor = r.id
    writeStorage(r.term, r.votedFor)
    r.timer = r.candidateTimer
    r.timer.Reset()
}
```

```
function HandleMessge(r: Raft, m: Message) {
    r.serverChannel <- m
}
```

```
function raftLoop(r: Raft) (
    for {
        select {
            m <- r.timer
            m <- r.serverCannel
                r.handle(m)
        }
    }
)
```

```
function handle(r: Raft) {
    // pass
}
```

```
function handleClientRequest(r: Raft, m: message) {
    r.index++
    r.progress[r.index] = Task{message: m}
    for c in r.clients
        cindex = r.clientIndex[c]
        m = Message{
                term:         r.term,
                type:         AppendRequest,
                from:         r.id,
                to:           c.id,
                index:        r.index,
                cindex:       cindex,
                prevLogTerm:  log[cindex - 1].term,
                prevLogIndex: log[cindex - 1].index,
                log:          log[cindex:] + m.log
            }
        c.send(m)
}
```

```
function handleVoteRequest(r: Raft, m: Message) {
    if r.term > m.term
        ok = false
        goto end

    if r.term < m.term
        if (r.log[-1].term < m.lastLogTerm) || (r.log[-1].term == m.lastLogTerm && r.log[-1].index <= m.lastLogIndex)
            r.becomeFollowerWithWrite(m.term, m.from)
            ok = true
            goto end
        else
            r.becomeFollowerWithWrite(m.term, null)
            ok = false
            goto end

    if r.term == m.term
        if (r.votedFor == null) && ((r.log[-1].term < m.lastLogTerm) || (r.log[-1].term == m.lastLogTerm && r.log[-1].index <= m.lastLogIndex))
            r.becomeFollowerWithWrite(m.term, m.from)
            ok = true
            goto end
        else if r.votedFor == m.from
            ok = true
            goto end
        else
            ok = false
            goto end
            
end:
    c = r.clients[m.from]
    m = Message{
            term:  r.term,
            type:  VoteResponse,
            from:  m.to,
            to:    m.from,
            index: m.index,
            ok:    ok
        }
    c.send(m)
}
```

```
function handleVoteResponse(r: Raft, m: Message) {
    if r.term > m.term
        if m.index in r.progress
            delete(r.progress, m.index)
        return
        
    if r.term < m.term
        if m.index in r.progress
            delete(r.progress, m.index)
        r.becomeFollowerWithWrite(m.term, null)
        return
    
    if r.term == m.term
        if m.index not in r.progress
            return
         
        t = r.progress[m.index]

        if m.ok
            t.success++
        else
            t.failure++
            
        if t.success > size
            r.becomeLeader()
            delete(r.progress, m.index)
            return
        
        if t.failure > size
            r.becomeFollower()
            delete(r.progress, m.index)
            return

        return
}
```

```
function handleAppendRequest(r: Raft, m: Message) {
    if r.term > m.term
        ok = false
        consistency = true
        goto end

    if r.term < m.term
        r.becomeFollowerWithWrite(m.term, m.from)
        if r.log[m.cindex - 1].term == m.prevLogTerm && r.log[m.cindex - 1].index == m.prevLogIndex
            r.log[m.cindex:] = m.log
            ok = true
            consistency = true
        else
            ok = false
            consistency = false
        goto end
        
    if r.term == m.term
        if r.votedFor == null
            r.becomeFollower(m.term, m.from)
        else
            r.becomeFollower()
        if r.log[m.cindex - 1].term == m.prevLogTerm && r.log[m.cindex - 1].index == m.prevLogIndex
            r.log[m.cindex:] = m.log
            ok = true
            consistency = true
        else
            ok = false
            consistency = false
        goto end
        
end:
    c = r.clients[m.from]
    m = Message{
            term:        r.term,
            type:        AppendResponse,
            from:        m.to,
            to:          m.from,
            index:       m.index,
            cindex:      m.cindex,
            ok:          ok,
            consistency: consistency
        }
    c.send(m)
}
```

```
function handleAppendResponse(r: Raft, m: Message) {
    if r.term > m.term
        if m.index in r.progress
            delete(r.progress, m.index)
        return
        
    if r.term < m.term
        if m.index in r.progress
            delete(r.progress, m.index)
        r.becomeFollowerWithWrite(m.term, null)
        return
        
    if r.term == m.term
        t = r.progress[m.index]
        c = r.clients[m.from]

        if not m.ok and not m.consistency
            if r.clientIndex[c] == m.cindex
                r.clientIndex[c]--

            /************ retry ********** 
            cindex = r.clientIndex[c]
            m = Message{
                    term:         m.term,
                    type:         m.type,
                    from:         m.from,
                    to:           m.to,
                    index:        m.index,
                    cindex:       cindex,
                    prevLogTerm:  log[cindex - 1].term,
                    prevLogIndex: log[cindex - 1].index,
                    log:          log[cindex:] + t.message.log
                }
            c.send(m)
            return
            *****************************/

        if m.index not in r.progress
            return

        if m.ok
            t.success++
        else
            t.failure++
            
        if t.success > size
            t.message.channel <- true
            delete(r.progress, m.index)
            return
        
        if t.failure > size
            t.message.channel <- false
            delete(r.progress, m.index)
            return

        return
}
```

```
function handleLeaderTimeout(r: Raft, m: Message) {
    r.timer.Reset()
    for c in r.clients
        cindex = r.clientIndex[c]
        m = Message{
                term:         r.term,
                type:         AppendRequest,
                from:         r.id,
                to:           c.id,
                index:        -1,
                cindex:       cindex,
                prevLogTerm:  log[cindex - 1].term,
                prevLogIndex: log[cindex - 1].index,
                log:          log[cindex:] + m.log
            }
        c.send(m)
}
```

```
function handleFollowerTimeout(r: Raft, m: Message) {
    r.becomeCandidate()
    r.index++
    r.progress[r.index] = Task{message: m}
    for c in r.clients
        m = Message{
                term:  r.term,
                type:  VoteRequest,
                from:  r.id,
                to:    c.id,
                index: r.index
            }
        c.send(m)
}
```

```
function handleCandidateTimeout(r: Raft, m: Message) {
    r.becomeCandidate()
    r.index++
    r.progress[r.index] = Task{message: m}
    for c in r.clients
        m = Message{
                term:  r.term,
                type:  VoteRequest,
                from:  r.id,
                to:    c.id,
                index: r.index
            }
        c.send(m)
}
```